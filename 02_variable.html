<script>
    /* ------------------------------#01 var vs let vs const------------------------------ */
    var msg1="hello";
    {
        var msg1="Good Luck";
    }
    console.log(msg1); // Good Luck
    
    var msg2="nice";
    function printOut_1(){
        var msg2="Thank you";
    };
    printOut_1();
    console.log(msg2); // nice

    // let : 스코프({}, 하나의 섹터를 갖고 있는 블록 영역)의 역할과 위치마다 내외부의 선언된 변수의 값을 일정하게 가져오기 위함
    // 변수를 let으로 선언시 스코프의 위치 및 함수 실행문에 상관없이 동일한 전역변수가 출력
    let msg3="hello";
    {
        let msg3="Good Luck";
    }
    console.log(msg3); // hello

    let msg4="nice";
    function printOut_2(){
        let msg4="Thank you";
    };
    printOut_2();
    console.log(msg4); // nice

    // const : 스코프({}, 하나의 섹터를 갖고 있는 블록 영역)의 역할과 위치마다 내외부의 선언된 변수의 값을 일정하게 가져오기 위함
    // 변수를 const로 선언시 스코프 및 함수 실행문 내 동일한 지역변수가 출력
    const msg5="hello";
    {
        const msg5="Good Luck";
        console.log(msg5); // Good Luck
    }

    const msg6="nice";
    function printOut_3(){
        const msg6="Thank you";
        console.log(msg6); // Thank you
    };
    printOut_3();

    /* ------------------------------#02 var vs let 상세비교------------------------------ */
    // 동일한 변수명으로 스코프 외부에 var 선언하고 스코프 내부에 let 선언하게 되면 충돌 위험이 있다! 
    if(true){
        var age1=20;
        console.log("당신의 나이 : ",age1); // 20(1차 출력)
    }
    console.log("당신의 나이 : ",age1); // 20(2차 출력)
    if(true){
        let age2=20;
        console.log("당신의 나이 : ",age2); // 20(1차 출력)
    }
    // console.log("당신의 나이 : ",age2); // 에러발생
    // 에러 발생 이유 : if(true){}에 내의 let 변수 선언은 스코프 영역 외부로 전달 불가능하기 때문
    
    if(true){
        // var age3=20;
        // console.log("당신의 나이 : ",age3);
    }
    // let age3=26;
    // console.log("당신의 나이 : ",age3);
    // 에러 발생 이유 : if(true){}에 내의 var 변수 선언이 스코프 영역 외부까지 영향을 미쳐 외부에 선언된 let 변수와 충돌하기 때문
    
    if(true){
        let age4=20;
        console.log("당신의 나이 : ",age4);
    }
    let age4=26;
    console.log("당신의 나이 : ",age4);

    // if(true){}에 내의 let 변수 선언은 스코프 영역 외부까지 영향을 미치지 못하므로 외부에 선언된 var 변수와 충돌하지 않음
    if(true){
        let age5=20;
        console.log("당신의 나이 : ",age5);
    }
    var age5=26;
    console.log("당신의 나이 : ",age5);
    /* ------------------------------#03 var vs const 상세비교------------------------------ */
    // const는 재할당이 불가능하다!
    const number1=20;
    const string1="spiderman";
    console.log("number : ",number1);
    console.log("string : ",string1);

    // [개발자 모드] 오류 : 02_various.html:89 Uncaught TypeError: Assignment to constant variable.
    // 에러 발생 이유 : const 재할당 불가
    const number2=20;
    const string2="spiderman";
    // number2=32; // 최초 설언 값에서 새로운 값 할당 불가
    // string2="betman";
    console.log("number : ",number2);
    console.log("string : ",string2);

    // 배열(array)의 경우 : 에러 발생 없음
    const num_arr=[25,35,45];
    num_arr.push(55);
    console.log("배열 데이터의 결과값 ",num_arr);
    
    // 에러 발생 이유 : const 재할당 불가
    const no_arr=["이미지", "타이틀"];
    // no_arr=["html", "javascript"];
    console.log("배열 데이터의 결과값 ",no_arr);

    // 객체 데이터일 경우, 객체 속성 변경하는 것은 에러 발생 없음
    const dessert={
        keyword : "빙그레 바나나 우유",
        category : "간식"
    };
    dessert.keyword="메로나";
    console.log("오늘의 간식? ",dessert);

    // 객체 데이터일 경우, 객체를 지정할 수 있는 케이스({}) 자체를 교체할 수 없음
    const fav_obj1={
        keyword : "빙그레 바나나 우유",
        category : "간식"
    };
    let fav_obj2={};
    fav_obj1.keyword="크림빵";
    console.log("오늘의 간식?",fav_obj1);
    // fav_obj1=fav_obj2; // 에러 발생
    console.log("오늘의 간식?",fav_obj1);
    /* ------------------------------#04 가변변수------------------------------ */
    let num=1;
    num=num*5;
    console.log(num);
    
    let str="문자형 데이터";
    str="다른 문자형 데이터";
    console.log(str);
    
    let arr=[];
    arr=["red", "orange", "yellow"];
    console.log(arr);
    
    let obj={};
    obj={attr1:"value1", attr2:"value2"};
    console.log(obj);
    /* ------------------------------#05 불변변수 const + 자바스크립트 내장함수 사용------------------------------ */
    // 에러 발생 이유 : let arr=[];과 충돌
    // const arr=[];
    // arr.push(1);
    // console.log(arr);

    const arr2=[];
    arr2.push(1);
    console.log(arr2);
    // splice(시작하는 인덱스 번호, 끝나는 인덱스 번호, 숫자)
    arr2.splice(0,0,0);
    console.log(arr2);
    
    arr2.pop();
    console.log(arr2);

    const obj2={};
    obj2["name"]="홍길동"
    console.log(obj2);
    Object.assign(obj2, {new1:"임꺽정"});
    console.log(obj2);

    delete obj2.name; // delete 객체의 항목 중에서 name의 속성을 삭제
    console.log(obj2);
    /* ------------------------------#06 ES6의 불변변수 const + 전개연산자 사용------------------------------ */
    const num1=1;
    const num2=num1*5; // 기존 불변변수의 재할당이 아니라 새로운 변수에 기존 불변변수의 이용 또는 추출이므로 에러발생 없음 
    console.log(num2);
    
    const str1="문자";
    const str2=str1+"추가";
    console.log(str2);

    const arr3=[];
    const arr4=arr3.concat(1);
    console.log(arr4);

    const arr5=[...arr4, 2, 3];
    console.log(arr5); // [1, 2, 3]
    
    // slice(a,b) : 인덱스 번호 a부터 b 이전 구간 반환 
    const arr6=arr5.slice(0,1); // splice와 다름
    console.log(arr6); // 1

    const [arr_first, ...arr_seventh]=arr5;
    console.log(arr_first); // 1
    console.log(arr_seventh); // [2, 3]

    const obj3={name:"홍길동", age:20, region:"인천"};
    const objValue={name:"", age:obj3.age};
    console.log(objValue); // {name: "", age: 20}

    const obj4={...obj3, name:"홍영만"}
    console.log(obj4); // {name: "홍영만", age: 20}

    // const {...obj5, name}=obj4; // [개발자 모드] Uncaught SyntaxError: Rest element must be last element
    // 객체의 항목명(name:"홍영만"이 아닌 name 입력)만을 입력시, 객체의 항목명이 먼저 선언되고 전개 연사자를 나중에 선언해야만 에러발생 없음
    // const {name, ...obj5}=obj4;
    const {age, ...obj5}=obj4;
    console.log(name); // 홍영만
    console.log(age); // 홍영만
    console.log(obj5); // {name: "홍영만", region: "인천"}







    



















</script>